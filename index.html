<!doctype html>
<html>
<head>
    <title>SFM Viewer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta original_author="yuyou">
    <meta original_source="https://gist.github.com/yuyou/2665238329ca34f0288b073d735a7bcb">
    <style>
        body {
            color: #ffffff;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            font-weight: bold;
            background-color: #000000;
            margin: 0px;
            padding: 0px;
            overflow: hidden;
        }
        #info {
            color:#ffffff;
            position: absolute;
            top: 0px; width: 100%;
            padding: 5px;
        }
        a {
            color: red;
        }
    </style>
</head>
<body>
<a href="https://github.com/district10/sfmViewer"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/567c3a48d796e2fc06ea80409cc9dd82bf714434/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png"></a>
<div id="container"></div>
<div id="info">
    sfm data viewer, for OpenMVG, VisualSFM, etc
</div>

<!--
<script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r67/three.min.js"></script>
<script src="http://threejs.org/examples/js/libs/stats.min.js"></script>
<script src="http://threejs.org/examples/js/Detector.js"></script>
<script src="https://stemkoski.github.io/Three.js/js/THREEx.WindowResize.js"></script>
<script src="http://threejs.org/examples/js/controls/TrackballControls.js"></script>
-->
<script src="jquery-3.1.0.min.js"></script>
<script src="three.js"></script>
<script src="stats.min.js"></script>
<script src="Detector.js"></script>
<script src="THREEx.WindowResize.js"></script>
<script src="FlyControls.js"></script>
<script src="dat.gui.js"></script>
<script>
    var load_image = true;
    var sfm_data;
    var stats, scene, renderer;
    var light, camera, axisHelper;
    var controls;
    var cameraFrustums = [], particles;
    var clock = new THREE.Clock();

    var Config = function() {
        this.pointColor = [255, 255, 255];
        this.pointSize = 0.01;
        this.cameraFrustumScale = 1;
        this.model = 'sfm_data.json';
        this.fileInput = $('<input type="file" />');
        this.fileInput.on("change", function(e){
            var f = e.target.files[0];
            if (f) {
                var r = new FileReader();
                r.onload = function(event) {
                    var text = event.target.result;
                    loadSfmFromText(text);
                };
                r.readAsText(f);
            }
        });

        this.loadModel = function() {
            this.fileInput.click();
        }
    };
    var config = new Config();
    var gui = new dat.GUI();
    gui.add(config, 'model', { OpenMVG: "sfm_data.json", VisualSFM: "sfm_data.nvm" } ).onChange(function(value){
        load_sfm( config.model );
    }).name("Models");
    gui.add(config, 'loadModel').name("Load Model");
    gui.add(config, 'cameraFrustumScale').min(0.1).max(5).step(0.1).onChange(function(value) {
        for (var i = 0; i < cameraFrustums.length; i++) {
            cameraFrustums[i].scale.set(value, value, value);
        }
    }).name("Camera Scale");
    var f1 = gui.addFolder('Point Cloud'); f1.open();
    f1.add(config, 'pointSize').min(0.01).max(0.25).step(0.005).onChange(function(value) {
        particles.material.size = value;
    }).name("Size");
    f1.addColor(config, 'pointColor').onFinishChange(function(value){
        particles.material.color = [value[0]/255.0, value[1]/255.0, value[2]/255.0];
    }).name("Color");

    $( document ).ready(function() {
        if( !init() )  { animate(); }
        load_sfm( config.model );
    });

    function load_sfm(url){
        console.log("loading "+url);
        if (url.endsWith(".json")) {
            $.getJSON(url, function(obj) {
                sfm_data = obj;
                init_scene();
                openmvg_create_camerapose_geometries();
                openmvg_create_pointcloud_geometry();
            }).fail(function(err) {
                log("Load '"+url+"' failed.");
            });
        } else if (url.endsWith(".nvm")) {
            console.log("loading "+url);
            $.get(url, function(text) {
                console.log(text.substring(0, 200));
                var model = parseNvmFile(text);
                if (model.valid) {
                    sfm_data = model;
                }
            }).fail(function(err) {
                log("Load '"+url+"' failed. (Notice: '.nvm' file can only be loaded via a web server)");
            });
        }
    }

    function _create_camera_geometry(texture_url) {

        var geometry1 = new THREE.PlaneGeometry( 0.2, 0.2 );
        var geometry2 = new THREE.PlaneGeometry( 0.2, 0.2 );
        geometry2.applyMatrix( new THREE.Matrix4().makeRotationY( Math.PI ) );
        geometry2.applyMatrix( new THREE.Matrix4().makeRotationZ( Math.PI ) );

        var material1 = new THREE.MeshBasicMaterial({color: 0xffff00, side: THREE.FrontSide});
        var material2;
        if (load_image) {
            material2 = new THREE.MeshBasicMaterial({
                map: new THREE.TextureLoader().load( texture_url )
            });
            console.log("Loading..."+texture_url);
        } else {
            material2 = new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.FrontSide});
        }

        var card = new THREE.Object3D();
        card.add( new THREE.Mesh( geometry1, material1 ));
        card.add( new THREE.Mesh( geometry2, material2 ));

        // now we add the normal line
        var _geometry = new THREE.Geometry();
        _geometry.vertices.push(new THREE.Vector3(0, 0, 0));
        _geometry.vertices.push(new THREE.Vector3(0, 0, 0.2));
        var _material = new THREE.LineBasicMaterial({
            color: 0x0000ff
        });
        var line = new THREE.Line(_geometry, _material);
        card.add(line);

        return card;
    }

    function init_scene() {
        scene.children = [];
        cameraFrustums = [];
        particles = {};
        scene.add(camera);
        scene.add(light);
        scene.add(axisHelper);
    }

    function openmvg_create_camerapose_geometries(){

        var camera_count = sfm_data.extrinsics.length;
        for (var i = 0; i < camera_count; i++) {

            var texture_url = sfm_data.root_path + '/' + sfm_data.views[i].value.ptr_wrapper.data.filename;
            var plane = _create_camera_geometry(texture_url);
            var center = sfm_data.extrinsics[i].value.center;
            plane.position.set(center[0], center[1], center[2]);
            var rotation = sfm_data.extrinsics[i].value.rotation;
            var rotationMatrix = new THREE.Matrix4();
            rotationMatrix.set(
                rotation[0][0], rotation[1][0], rotation[2][0],     0,
                rotation[0][1], rotation[1][1], rotation[2][1],     0,
                rotation[0][2], rotation[1][2], rotation[2][2],     0,
                0,              0,              0,     1 );
            plane.quaternion.setFromRotationMatrix(rotationMatrix);
            plane.isCameraFrustum = true;

            scene.add(plane);
            cameraFrustums.push(plane);
        }
    }

    function nvm_create_camerapose_geometries() {

        var camera_count = sfm_data.cameras.length;
        for (var i = 0; i < camera_count; i++) {

            var view = sfm_data.cameras[i];
            var path = view.path;
            var texture_url = path.substring(path.lastIndexOf('/')+1);
            var plane = _create_camera_geometry("images/src/"+texture_url);
            var center = view.X;
            plane.position.set(center[0], center[1], center[2]);
            plane.quaternion.set(view.quaternion);
            plane.isCameraFrustum = true;
            scene.add(plane);
            cameraFrustums.push(plane);
        }
    }

    function openmvg_create_pointcloud_geometry(){
        var materials = [];
        var geometry = new THREE.Geometry();
        var particleCount = sfm_data.structure.length;

        for (var i = 0; i < particleCount; i++) {
            var p = sfm_data.structure[i].value.X;
            var vertex = new THREE.Vector3(p[0],p[1],p[2]);
            geometry.vertices.push(vertex);
        }

        var material = new THREE.PointsMaterial({
            color: [1, 1, 1],
            size: 0.01
        });
        particles = new THREE.Points(geometry, material);
        particles.isParticles = true;
        scene.add(particles);
    }

    function nvm_create_pointcloud_geometry(){
        var materials = [];
        var geometry = new THREE.Geometry();
        var particleCount = sfm_data.points.length;

        for (var i = 0; i < particleCount; i++) {
            var p = sfm_data.points[i].X;
            var vertex = new THREE.Vector3(p[0],p[1],p[2]);
            geometry.vertices.push(vertex);
        }

        var material = new THREE.PointsMaterial({
            color: [1, 1, 1],
            size: 0.01
        });
        particles = new THREE.Points(geometry, material);
        particles.isParticles = true;
        scene.add(particles);
    }

    // init the scene
    function init(){

        if( Detector.webgl ){
            renderer = new THREE.WebGLRenderer({
                antialias               : true,   // to get smoother output
                preserveDrawingBuffer : true    // to allow screenshot
            });
            renderer.setClearColor( 0xbbbbbb );
        } else {
            Detector.addGetWebGLMessage();
            return true;
        }
        renderer.setClearColor( 0x000000 );
        renderer.setSize( window.innerWidth, window.innerHeight );
        var container = document.getElementById('container');
        container.appendChild(renderer.domElement);
        if (container.children.length > 1) {
            container.removeChild(container.children[0]);
        }

        // add Stats.js - https://github.com/mrdoob/stats.js
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = ""
        stats.domElement.style.bottom = '0px';
        stats.domElement.style.left = ""
        stats.domElement.style.right = '0px';
        document.body.appendChild( stats.domElement );

        // create a scene
        scene = new THREE.Scene();
        // put a camera in the scene
        camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.01, 1000 );
        cameraposition.set(0, -1, -1); camera.up.y = -150;
        // camera.applyMatrix( new THREE.Matrix4().makeRotationZ( Math.PI ) );

        // create a camera contol
        controls = new THREE.FlyControls( camera, container );
        controls.movementSpeed = 1000;
        controls.rollSpeed = Math.PI / 24;
        controls.autoForward = false;
        controls.dragToLook = false;

        // transparently support window resize
        THREEx.WindowResize.bind(renderer, camera);

        light = new THREE.AmbientLight( 0.3 * 0xffffff );
        axisHelper = new THREE.AxisHelper(500);

    }

    // animation loop
    function animate() {
        requestAnimationFrame( animate );
        // do the render
        render();
        // update stats
        stats.update();
    }

    // render the scene
    function render() {
        // update camera controls
        var delta = clock.getDelta();
        controls.update( delta );
        // actually render the scene
        renderer.render( scene, camera );
    }

    document.addEventListener( 'dragover', function ( event ) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
    }, false );

    document.addEventListener( 'dragenter', function ( event ) {
        document.body.style.opacity = 0.5;
    }, false );

    document.addEventListener( 'dragleave', function ( event ) {
        document.body.style.opacity = 1;
    }, false );

    document.addEventListener( 'drop', function ( event ) {
        event.preventDefault();
        var reader = new FileReader();
        reader.addEventListener( 'load', function ( event ) {
            var text = event.target.result;
            loadSfmFromText(text);
        }, false );
        reader.readAsText ( event.dataTransfer.files[ 0 ] );
        if( !init() )  { animate(); }
        document.body.style.opacity = 1;
    }, false );

    function parseNvmFile(text) {
        // Doc: http://ccwu.me/vsfm/doc.html#The output format: N-View Match (NVM)
        var model = { }; model.valid = true;
        var lines = text.split("\n");
        // check file header
        if (lines.length < 10 || !lines[0].trim().toLowerCase().startsWith("nvm")) {
            model.valid = false;
            return model;
        }
        // views
        var i = 1;
        do {
            model.nCameras = parseInt(lines[i++]);
        } while(isNaN(model.nCameras));
        model.cameras = [];
        for (var j = 0; j < model.nCameras; j++) {
            var parts = lines[i++].split('\t');
            if (parts.length === 2) {
                var nums = parts[1].trim().split(' ');
                if (nums.length === 10 && parseInt(nums[9]) === 0) {
                    var v = {};
                    v.path = parts[0].trim().replace(/\\/g, "/");
                    v.focal = parseFloat(nums[0]);
                    v.quaternion = [ // quaternion WXYZ
                        parseFloat(nums[1]),
                        parseFloat(nums[2]),
                        parseFloat(nums[3]),
                        parseFloat(nums[4])
                    ];
                    v.X = [ // camera center
                        parseFloat(nums[5]),
                        parseFloat(nums[6]),
                        parseFloat(nums[7])
                    ];
                    v.disto = parseFloat(nums[8]);
                    model.cameras.push(v);
                }
            }
        }
        if (model.cameras.length !== model.nCameras) {
            model.valid = false;
            return model;
        }
        // points
        do {
            model.nPoints = parseInt(lines[i++]);
        } while(isNaN(model.nPoints));
        model.points = [];
        for (var j = 0; j < model.nPoints; j++) {
            var nums = lines[i++].trim().split(' ');
            var invalid = false;
            var p = {};
            if (nums.length >= 7) {
                var nObserve = parseInt(nums[6]);
                if (!isNaN(nObserve) && nObserve > 0 && (nObserve*4+7) === nums.length) {
                    p.X = [
                        parseFloat(nums[0]),
                        parseFloat(nums[1]),
                        parseFloat(nums[2])
                    ];
                    p.color = [
                        parseInt(nums[3]),
                        parseInt(nums[4]),
                        parseInt(nums[5])
                    ];
                    p.measurements = [];
                    for (var k = 0; k < nObserve; k++) {
                        var m = {};
                        m.imageIndex = parseInt(nums[7+k*4+0]);
                        m.featureIndex = parseInt(nums[7+k*4+1]);
                        m.x = parseFloat(nums[7+k*4+2]);
                        m.y = parseFloat(nums[7+k*4+3]);
                        p.measurements.push(m);
                    }
                }
            }
            model.points.push(p);
        }
        if (model.points.length !== model.nPoints) {
            model.valid = false;
            return model;
        }
        // TODO, parse more
        return model;
    }

    function log(msg) {
        $("#info")[0].innerHTML = msg;
    }

    function loadSfmFromText(text) {
        var header = text.substring(0, 20).split('\n').join('');
        if (header.startsWith('{')) {
            sfm_data = JSON.parse(text);
            if (sfm_data["sfm_data_version"]) {
                // OpenMVG
                init_scene();
                openmvg_create_camerapose_geometries();
                openmvg_create_pointcloud_geometry();
            }
        } else if (header.toLowerCase().startsWith('nvm')) {
            // VisualSFM nvm file
            var model = parseNvmFile(text);
            if (model.valid) {
                sfm_data = model;
                init_scene();
                nvm_create_camerapose_geometries();
                nvm_create_pointcloud_geometry();
            }
        }
    }
</script>
</body>
</html>
